import { Button, VerticalBox, HorizontalBox } from "std-widgets.slint";
import { MultiChoice, RegularText, TitleText, ScrollChoice, ChoiceElem, SwipeInfo, ImageChoice} from "widgets.slint";
import { TxtOrImg, ChoiceState, ChoicePlayUpdate } from "structs.slint";
import { TextStyle, FontSettings, Palette, Sizes } from "styling.slint";

export component ChoicePlayScreen inherits Rectangle {
    callback changed(was_guessed:[bool], next:bool, found:bool);
    property <TxtOrImg> info: {
        is_txt: false,
        txt: "Kingston",
        img: @image-url("../data/positions2/jam.svg"),
    };
    property <[TxtOrImg]> guesses : [
        {
            is_txt : true,
            txt: "Singapore", 
            img: @image-url("../data/flags/fra.svg")
        },
        {
            is_txt : true,
            txt: "Jamaica", 
            img: @image-url("../data/flags/jam.svg")
        },
        {
            is_txt : true,
            txt: "France", 
            img: @image-url("../data/flags/fra.svg")
        },
        {
            is_txt : true,
            txt: "Brazil", 
            img: @image-url("../data/flags/fra.svg")
        },
    ];
    property <int> correct_guess : 1;
    property <int> guess_num : 0;
    property <bool> found : false;
    property <[ChoiceState]> guess_states : [ChoiceState.NotClicked, ChoiceState.NotClicked, ChoiceState.NotClicked, ChoiceState.NotClicked];
    property <string> default_info: "Jamaica";
    property <int> num:0;
    property <int> out_of:110;

    public function update_screen(info : ChoicePlayUpdate) {

        root.guess_num = info.guess_num;
        root.found = info.prev_guess[info.correct_guess];
        guess_states[0] = info.prev_guess[0] ? ChoiceState.Wrong : ChoiceState.NotClicked;
        guess_states[1] = info.prev_guess[1] ? ChoiceState.Wrong : ChoiceState.NotClicked;
        guess_states[2] = info.prev_guess[2] ? ChoiceState.Wrong : ChoiceState.NotClicked;
        guess_states[3] = info.prev_guess[3] ? ChoiceState.Wrong : ChoiceState.NotClicked;
        if root.found {
            guess_states[info.correct_guess] = ChoiceState.Correct;
        }
        root.num = info.num;
        root.out_of = info.out_of;
        root.info = info.info;
        root.guesses = info.guesses;
        root.correct_guess = info.correct_guess;
        root.default_info = info.default_info;
    }

    public function collect_changed(next:bool, found: bool) {
        root.changed([
            !(root.guess_states[0]==ChoiceState.NotClicked),
            !(root.guess_states[1]==ChoiceState.NotClicked),
            !(root.guess_states[2]==ChoiceState.NotClicked),
            !(root.guess_states[3]==ChoiceState.NotClicked),
        ], next, found);
    }

    timer := Timer {
        interval: 200ms;
        running: false;
        triggered() => {
            self.running = false;
            collect_changed(true, true);
        }
    }

    VerticalLayout {
        padding: Sizes.padding;
        spacing: Sizes.spacing;
        TitleText {
            text: "\{root.num + 1} / \{root.out_of}";
        }
        SwipeInfo {
            info : root.info;
            handle-swipe-right: root.num > 0;
            handle-swipe-left: root.num < root.out_of - 1;
            height: root.width / 16*9;
            prev => {collect_changed(false, false)}
            next => {collect_changed(true, false)}
        }
       
        RegularText {
            visible: root.found;
            text: root.default_info == "" ? "Guess N°\{root.guess_num}": "Guess N°\{root.guess_num} (\{root.default_info})";
            horizontal-alignment: center;
        }
        Rectangle {
            VerticalLayout {
                visible: root.guesses[0].is_txt;
                padding: 0;
                spacing: Sizes.spacing;
                for text[i] in root.guesses : ChoiceElem {
                    text: root.guesses[i].txt;
                    state: guess_states[i];
                    height: Sizes.height_multi_choice;
                    clicked => {
                        if root.found {
                            return;
                        }
                        root.guess_num += 1;
                        if i == root.correct_guess {
                            root.guess_states[i] = ChoiceState.Correct;
                            root.found = true;
                            timer.running = true;
                        } else {
                            root.guess_states[i] = ChoiceState.Wrong;
                        }
                    }
                }
            }
            Rectangle {
                // grid layout doesn't support for loops so I made my own
                visible: !root.guesses[0].is_txt;
                padding: 0;
                for t[i] in root.guesses : ImageChoice {
                    state: guess_states[i];
                    height: root.height /4;
                    width: (root.width - (Sizes.padding*2 + Sizes.spacing))/2; 
                    x: i==0 || i == 2 ? 0: self.width + Sizes.spacing;
                    y: i==0 || i == 1 ? 0: self.height + Sizes.spacing;
                    image : root.guesses[i].img;
                    clicked => {
                        if root.found || root.guess_states[i] != ChoiceState.NotClicked{
                            return;
                        }
                        root.guess_num += 1;
                        if i == root.correct_guess {
                            root.guess_states[i] = ChoiceState.Correct;
                            root.found = true;
                            timer.running = true;
                        } else {
                            root.guess_states[i] = ChoiceState.Wrong;
                        }
                    }
                }
            }
        }
        
        Rectangle{

        }
    }
}