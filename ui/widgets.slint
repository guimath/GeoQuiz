import { Button, VerticalBox, HorizontalBox, TextEdit, CheckBox, ComboBox, ScrollView } from "std-widgets.slint";
import { CatInfo, ChoiceState, TxtOrImg} from "structs.slint";


export component RegularText inherits Text {
    // font-family: 
    font-size: 12pt;
    // color: white;
}
export component TitleText inherits Text {
    font-size: 20pt;
    height : 40px;
    horizontal-alignment: center;
    vertical-alignment: center;
}

export component ChoiceElem inherits TouchArea {
    in property <string> text;
    in property <ChoiceState> state : ChoiceState.NotClicked;
    in property <color> background_elem: 
        root.state == ChoiceState.NotClicked?  #ffffff3c:
        root.state == ChoiceState.Correct?  #146d00:
        #9a0000;
    in property <length> radius: 10px;
    public function click() {
        root.clicked();
    } 
    width: 20%;
    height: 30pt;
    Rectangle {
        width: 100%;
        border-radius: radius;
        background: root.background_elem;
    }
    RegularText {
        height: 30pt;
        width:100%;
        horizontal-alignment: center;
        vertical-alignment: center;
        wrap: word-wrap;
        text: root.text;
    }
}
export component MultiChoice {
    in property <[string]> choices;
    in property <float> choices_len;
    in property <percent> width_per_elem: 20%;
    in property <length> spacing : 10pt;
    in property <color> background_elem : #ffffff3c;
    in-out property <int> choice_num : 0;
    out property <bool> not_default : root.choice_num != 0;
  
    HorizontalBox {
        padding: 0;
        spacing: root.spacing;
        alignment: center;
        for text[index] in root.choices : ChoiceElem {
            text: text;
            width: width_per_elem;
            background_elem: root.background_elem;
            clicked => {root.choice_num = index}
        }
            
        
    }
    e := Rectangle {
        width: root.width_per_elem;
    }
    highlight := Rectangle{
        x: (root.width - e.width*root.choices_len - root.spacing*(root.choices_len - 1))/2 + (e.width+root.spacing)*root.choice_num;
        background: #ffffff3c;
        height: 30pt;
        width:root.width_per_elem;
        border-radius: 10px;
        animate x {
            duration: 300ms;
            easing: ease-in-out;
        }
    }
}


component ToggleStar inherits TouchArea {
    in property <bool> on: false;
    in property <bool> semi: true;
    height: 40px;
    width: 40px;
    im := Image {
        height: 40px;
        width: 40px;
        source: @image-url("star.svg");
        colorize: on? #e2cb00:
            root.semi? @radial-gradient(circle, white 0%, #e2cb00 100%)://#f2edbc: 
            white;
    }
}

export component ThreeStartScore {
    in-out property <int> score:0;
    in-out property <int> prev_score:2;
    callback score_changed(score: int);
    VerticalBox {
        padding: 0;
        HorizontalBox {
            padding: 0;
            for i in [0, 1, 2, 4, 5] : ToggleStar {
                clicked => {
                    root.score = i+1;
                    root.prev_score = i+1;
                    score_changed(i+1);
                }
                on: root.score>i;
                semi: root.prev_score>i;
            }
           
        }
    }
}


export component HiddenText inherits TouchArea {
    in-out property <string> name;
    in-out property <string> first_letter;
    in-out property <string> type;
    in property <bool> show;
    in-out property <bool> show_first_letter;
    in-out property <length> size_hint: 40pt;
    in property <int> play_mode; 
    callback hint();

    public function update_cat(cat: CatInfo) {
        self.type = cat.category;
        self.name = cat.full;
        self.first_letter = cat.first;

        if root.play_mode == 1 && cat.with_hint && !root.show { 
            self.size_hint = 40pt;
        }
        else {
            self.size_hint = 0pt;
        }

        if root.play_mode == 2 && cat.with_hint {
            self.show_first_letter = true;
        }
        else {
            self.show_first_letter = false;
        }

    }
    

    VerticalBox {
        padding: 0;
        Rectangle {
            background: #4a4458ff;
            border-radius: 10px;
            preferred-height: 70pt;
            HorizontalLayout {
                padding: 0;
                padding-left: 10px;
                padding-right: 10px;
                w_type := RegularText {
                    horizontal-alignment: right;
                    vertical-alignment: center;
                    text: "\{root.type}:";
                }
                Rectangle {width: 10px;}
                RegularText { 
                    horizontal-stretch: 1;
                    vertical-stretch: 1;
                    height: 100%;
                    horizontal-alignment: left;
                    vertical-alignment: center;
                    text: show ? root.name: root.first_letter;
                    visible: root.show || root.show_first_letter;
                    wrap: word-wrap;
                }
                
                
            }   
        }
        
    }
    
    TouchArea {
        x : root.width - root.size_hint - 10px;
        height: root.size_hint;
        width: root.size_hint;
        clicked => {
            hint();
            root.size_hint = 0;
            root.show_first_letter = true
        }
        animate height, width {
            duration: 300ms;
            easing: ease-in-out;
        }
    }
    Image {
        x : root.width - root.size_hint  - 10px;
        source: @image-url("hint.svg");
        height: root.size_hint;
        width: root.size_hint;
        animate height, width, x {
            duration: 400ms;
            easing: ease-in-out;
        }
    }
}

export component ScrollChoice inherits HorizontalLayout {
    in property <[string]> choices: ["Country", "Capital", "Languages", "Borders", "Region", "Currencies"];
    in property <length> width_per_elem: (root.width - root.spacing_i *2 - 2*root.size_bar - 2*root.width_arrow)/3;
    in-out property <int> choice_num:0;
    in property <length> spacing_i: 20px;
    in property <length> width_arrow: 6pt;
    in property <length> height_elem: 30pt;
    property <length> size_bar: 12px; // bar is showing on modern-black
    property <length> Width_w_spacing : root.spacing_i + root.width_per_elem;

    function set_x() -> length {
        return - (root.choice_num* (root.width_per_elem+ root.spacing_i));
    }
    alignment: center;
    padding: 0;
    spacing: 0;
    TouchArea {
        height: root.height_elem;
        width: root.width_arrow;

        Image {
            height: 100%;
            width: 100%;
            source: @image-url("arrow_left.svg");
            colorize: root.choice_num == 0 ? #ffffff55: white;
        }
        clicked => {
            if root.choice_num > 0 {root.choice_num -= 1;}
            scroll.viewport-x= set_x();
        }
    }

    Rectangle {
        width: root.size_bar;
    }
    scroll := ScrollView {

        height: root.height_elem +root.size_bar;
        viewport-height: root.height_elem;
        horizontal-scrollbar-policy: always-off;
        width: 3*width_per_elem+ 2*root.spacing_i + root.size_bar;
        viewport-x: set_x();
        
        HorizontalLayout {
            padding: 0;
            spacing: root.spacing_i;
            Rectangle {width: root.width_per_elem;}
            for text[index] in root.choices : ChoiceElem {
                height: root.choice_num == index ? root.height_elem: root.height_elem - 5pt;
                text: text;
                width: root.width_per_elem;
                background_elem: index == root.choice_num ? #ffffff62 : #ffffff3c;
                clicked => {root.choice_num = index; scroll.viewport-x= set_x();}
                animate height {
                    duration: 50ms;
                    easing: ease-in;
                     
                }
            }
            Rectangle {width: width_per_elem;}
        }

        scrolled() => {
            if scroll.viewport-x >= set_x() + root.spacing_i + root.width_per_elem/2 {
                root.choice_num -= 1;
            } 
            else if scroll.viewport-x <= set_x() - root.spacing_i - root.width_per_elem/2 {
                root.choice_num += 1;
            }
        }
    }
    TouchArea {
        height: root.height_elem;
        width: root.width_arrow;

        Image {
            height: 100%;
            width: 100%;
            source: @image-url("arrow_left.svg");
            rotation-angle: -180deg;
            colorize: root.choice_num == choices.length - 1 ? #ffffff55: white;
        }
        clicked => {
            if root.choice_num < (choices.length - 1) {root.choice_num += 1;}
            scroll.viewport-x= set_x();
        }
    }
}

export component SwipeInfo inherits SwipeGestureHandler {
    callback prev();
    callback next();
    in property <TxtOrImg> info;
    swiped => {
        if self.current-position.x > self.pressed-position.x + self.width / 4 {
            prev();
        } else if self.current-position.x < self.pressed-position.x - self.width / 4 {
            next();
        }
    }

    Rectangle {
        Image {
            height: 100%;
            visible: !root.info.is-txt;
            width: 100%;
            source: root.info.img;
            image-fit: contain;
        }

        TitleText {
            height: 100%;
            width: 100%;
            visible: root.info.is-txt;
            text: root.info.txt;
        }
    }
}


export component ImageChoice inherits TouchArea {
    in property <image> image;
    in property <ChoiceState> state : ChoiceState.NotClicked;
    in property <color> background_elem: 
        root.state == ChoiceState.NotClicked?  #ffffff3c:
        root.state == ChoiceState.Correct?  #146d00:
        #9a0000;
    in property <length> radius: 10px;
   
    height: 30pt;
    Rectangle {
        // width: 100%;
        // height: 100%;
        border-radius: radius;
        background: root.background_elem;
    }
    HorizontalBox {
        padding: 10px;
        Image {
            // height: 100%;
            // width: root.width - 20px;
            source: root.image;
            image-fit: contain;
        }
    }
}